###
#  Author: Cory M. Simon (CoryMSimon@gmail.com)
###
include("framework.jl")
include("forcefield.jl")
include("energyutils.jl")
include("adsorbates.jl")
include("getEwaldparams.jl")
using Optim
using Graphs


function write_vdW_grid(adsorbatename::AbstractString, 
                   structurename::AbstractString, 
                   forcefieldname::AbstractString; 
                   gridspacing=0.1, 
                   cutoff=12.5, 
                   temperature::Float64=-1.0, 
                   num_rotation_samples::Int=1000)
    """
    Compute the potential energy of an adsorbate molecule on a 3D grid of points superimposed on the unit cell of the structure.
    Computes only van der Waals energies

    The grid is written to a file `structurename.cube`, in Gaussian cube format. The units of the energy are kJ/mol.

    :param: AbstractString adsorbate: the name of the adsorbate molecule, corresponding to the forcefield file
    """
    @printf("Constructing framework object for %s...\n", structurename)
    framework = Framework(structurename)
    
    @printf("Constructing adsorbate %s...\n", adsorbatename)
    adsorbate = Adsorbate(adsorbatename)
    if (adsorbate.nbeads > 1) & (temperature == -1.0)
        error("Provide temperature for Boltzmann weighted rotations, nbeads > 1 in adsorbate.")
    end

    @printf("Constructing forcefield(s) for bead(s) in %s...\n", forcefieldname)
    forcefields = Forcefield[]  # list of forcefields
    for b = 1:adsorbate.nbeads
        @printf("\tBead %s...\n", adsorbate.bead_names[b])
        push!(forcefields, Forcefield(forcefieldname, adsorbate.bead_names[b], cutoff=cutoff))
    end
    
    # get unit cell replication factors for periodic BCs
    rep_factors = get_replication_factors(framework, cutoff)
    @printf("Unit cell replication factors for LJ cutoff of %.2f A: %d by %d by %d\n", cutoff, rep_factors[1], rep_factors[2], rep_factors[3])

    # how many grid points in each direction? 
    N_x = round(Int, framework.a / gridspacing) + 1
    N_y = round(Int, framework.b / gridspacing) + 1
    N_z = round(Int, framework.c / gridspacing) + 1
    @printf("Grid is %d by %d by %d points, a total of %d grid points.\n", N_x, N_y, N_z, N_x*N_y*N_z)
    # fractional grid point spacing. Think of grid points as center of voxels.
    dx_f = 1.0 / (N_x - 1)
    dy_f = 1.0 / (N_y - 1)
    dz_f = 1.0 / (N_z - 1)
    @printf("Fractional grid spacing: dx_f = %f, dy_f = %f, dz_f = %f\n", dx_f, dy_f, dz_f)

    # get fractional coords of energy grid. 
    xf_grid = linspace(0.0, 1.0, N_x)
    yf_grid = linspace(0.0, 1.0, N_y)
    zf_grid = linspace(0.0, 1.0, N_z)
    
    # get grid point spacing in Cartesian space, just for kicks ^.^
    cartesian_spacing = framework.f_to_cartesian_mtrx * [xf_grid[2]-xf_grid[1], yf_grid[2]-yf_grid[1], zf_grid[2]-zf_grid[1]]
    @printf("Grid spacing: dx = %.2f, dy = %.2f, dz = %.2f\n", cartesian_spacing[1], cartesian_spacing[2], cartesian_spacing[3])

    # get array of framework atom positions and corresponding epsilons and sigmas for speed
    epsilons, sigmas = _generate_epsilons_sigmas(framework, forcefields)
    
    # open grid file
    if ! isdir(homedir() * "/PEGrid_output/" * forcefieldname)
       mkdir(homedir() * "/PEGrid_output/" * forcefieldname)
    end
    gridfilename = homedir() * "/PEGrid_output/" * forcefieldname * "/" * framework.structurename * "_" * adsorbatename * ".cube"
    gridfile = open(gridfilename, "w")

    # Format of .cube described here http://paulbourke.net/dataformats/cube/
    write(gridfile, "This is a grid file generated by PEGrid\nLoop order: x, y, z\n")
    @printf(gridfile, "%d %f %f %f\n" , 0, 0.0, 0.0, 0.0)  # 0 atoms, then origin
    # TODO list atoms in the crystal structure
    @printf(gridfile, "%d %f %f %f\n" , N_x, framework.f_to_cartesian_mtrx[1,1] / (N_x - 1), 0.0, 0.0)  # N_x, vector along x-edge of voxel
    @printf(gridfile, "%d %f %f %f\n" , N_y, framework.f_to_cartesian_mtrx[1,2] / (N_y - 1), framework.f_to_cartesian_mtrx[2,2] / (N_y - 1), 0.0)  # N_y, vector along y-edge of voxel
    @printf(gridfile, "%d %f %f %f\n" , N_z, framework.f_to_cartesian_mtrx[1,3] / (N_z - 1), framework.f_to_cartesian_mtrx[2,3] / (N_z - 1), framework.f_to_cartesian_mtrx[3,3] / (N_z - 1))

    @printf("Writing grid...\n")
    # loop over [fractional] grid points, compute energies
    for i in 1:N_x  # loop over x_f-grid points
        # print progress
        if i % (round(Int, N_x/10.0)) == 0
            @printf("\tPercent finished: %.1f\n", 100.0*i/N_x)
        end

        for j in 1:N_y  # loop over y_f-grid points
            for k in 1:N_z  # loop over z_f-grid points
                
                # translate adsorbate to grid pt
                adsorbate.translate_to(framework.f_to_cartesian_mtrx * [xf_grid[i], yf_grid[j], zf_grid[k]])
                
                # compute energy here
                if adsorbate.nbeads == 1  # no need for sampling rotations
                    E = _vdW_energy_of_adsorbate!(adsorbate,
                                              epsilons,
                                              sigmas,
                                              framework,
                                              rep_factors,
                                              cutoff)
                else  # need to sample rotations and get boltzmann-weighted average
                    boltzmann_weight_sum = 0.0
                    weighted_energy_sum = 0.0
                    for rot = 1:num_rotation_samples
                        adsorbate.perform_uniform_random_rotation()

                        _energy = _vdW_energy_of_adsorbate!(adsorbate,
                                                    epsilons,
                                                    sigmas,
                                                    framework,
                                                    rep_factors, 
                                                    cutoff)

                        boltzmann_weight = exp(-_energy / temperature)
                        boltzmann_weight_sum += boltzmann_weight
                        weighted_energy_sum += boltzmann_weight * _energy
                    end
                    E = weighted_energy_sum / boltzmann_weight_sum
                end
                
                # write energy at this point to grid file
                @printf(gridfile, "%e ", E * 8.314 / 1000.0)  # store in kJ/mol
                if (k % 6) == 0
                    @printf(gridfile, "\n")
                end

            end # end loop in z_f-grid points
            @printf(gridfile, "\n")
        end # end loop in y_f-grid points
    end # end loop in x_f-grid points
    close(gridfile)
    @printf("\tDone.\nGrid available in %s\n", gridfilename)
end

function write_electrostatic_grid(structurename::AbstractString, 
                   gridspacing=0.1, 
                   sr_cutoff=12.5;
                   EWald_precision=1e-6)
    """
    Compute the electrostatic potential energy inside a nanoporous crystalline material

    The grid is written to a file `structurename_electrostatic.cube`, in Gaussian cube format. The units of the energy are kJ/mol.
    """
    @printf("Constructing framework object for %s...\n", structurename)
    framework = Framework(structurename)
    
    # get unit cell replication factors for periodic BCs
    rep_factors = get_replication_factors(framework, sr_cutoff)
    @printf("Unit cell replication factors for short-range cutoff of %.2f A: %d by %d by %d\n", sr_cutoff, rep_factors[1], rep_factors[2], rep_factors[3])

    # how many grid points in each direction? 
    N_x = round(Int, framework.a / gridspacing) + 1
    N_y = round(Int, framework.b / gridspacing) + 1
    N_z = round(Int, framework.c / gridspacing) + 1
    @printf("Grid is %d by %d by %d points, a total of %d grid points.\n", N_x, N_y, N_z, N_x*N_y*N_z)
    # fractional grid point spacing. Think of grid points as center of voxels.
    dx_f = 1.0 / (N_x - 1)
    dy_f = 1.0 / (N_y - 1)
    dz_f = 1.0 / (N_z - 1)
    @printf("Fractional grid spacing: dx_f = %f, dy_f = %f, dz_f = %f\n", dx_f, dy_f, dz_f)

    # get fractional coords of energy grid. 
    xf_grid = linspace(0.0, 1.0, N_x)
    yf_grid = linspace(0.0, 1.0, N_y)
    zf_grid = linspace(0.0, 1.0, N_z)
    
    # get grid point spacing in Cartesian space, just for kicks ^.^
    cartesian_spacing = framework.f_to_cartesian_mtrx * [xf_grid[2]-xf_grid[1], yf_grid[2]-yf_grid[1], zf_grid[2]-zf_grid[1]]
    @printf("Grid spacing: dx = %.2f, dy = %.2f, dz = %.2f\n", cartesian_spacing[1], cartesian_spacing[2], cartesian_spacing[3])

    # get EWald summation params
    alpha, k_reps = getEwaldparams(framework, sr_cutoff, EWald_precision, verboseflag=true)

    # open grid file
    if ! isdir(homedir() * "/PEGrid_output/electrostatic_grids")
       mkdir(homedir() * "/PEGrid_output/electrostatic_grids")
    end
    gridfilename = homedir() * "/PEGrid_output/electrostatic_grids" * framework.structurename * ".cube"
    gridfile = open(gridfilename, "w")

    # Format of .cube described here http://paulbourke.net/dataformats/cube/
    write(gridfile, "This is a grid file generated by PEviz\nLoop order: x, y, z\n")
    @printf(gridfile, "%d %f %f %f\n" , 0, 0.0, 0.0, 0.0)  # 0 atoms, then origin
    # TODO list atoms in the crystal structure
    @printf(gridfile, "%d %f %f %f\n" , N_x, framework.f_to_cartesian_mtrx[1,1] / (N_x - 1), 0.0, 0.0)  # N_x, vector along x-edge of voxel
    @printf(gridfile, "%d %f %f %f\n" , N_y, framework.f_to_cartesian_mtrx[1,2] / (N_y - 1), framework.f_to_cartesian_mtrx[2,2] / (N_y - 1), 0.0)  # N_y, vector along y-edge of voxel
    @printf(gridfile, "%d %f %f %f\n" , N_z, framework.f_to_cartesian_mtrx[1,3] / (N_z - 1), framework.f_to_cartesian_mtrx[2,3] / (N_z - 1), framework.f_to_cartesian_mtrx[3,3] / (N_z - 1))

    @printf("Writing grid...\n")
    # loop over [fractional] grid points, compute energies
    for i in 1:N_x  # loop over x_f-grid points
        # print progress
        @printf("\tPercent finished: %.1f\n", 100.0*i/N_x)

        for j in 1:N_y  # loop over y_f-grid points
            for k in 1:N_z  # loop over z_f-grid points
                
                xyz_coord = framework.f_to_cartesian_mtrx * [xf_grid[i], yf_grid[j], zf_grid[k]]
                E = _electrostatic_potential(xyz_coord, framework, rep_factors, sr_cutoff, alpha, k_reps, precision=EWald_precision)
                 
                # write energy at this point to grid file
                @printf(gridfile, "%e ", E * 8.314 / 1000.0)  # store in kJ/mol
                if (k % 6) == 0
                    @printf(gridfile, "\n")
                end

            end # end loop in z_f-grid points
            @printf(gridfile, "\n")
        end # end loop in y_f-grid points
    end # end loop in x_f-grid points
    close(gridfile)
    @printf("\tDone.\nGrid available in %s\n", gridfilename)
end

function note_new_connection(graph::GenericEdgeList, source::Int, target::Int, direction::Tuple{Int, Int, Int})
    """
    Note new connection between source and target vertex;
    each vertex represents a segment.
    edges have attributes: the direction in which we travel across the unit cell
    when moving from source to target vertex
    only add edge if the edge is not already present

    parameters:
        graph: Graph.jl object
        source: segment number
        target: segment number
        direction:: Tuple, direction we travel across the unit cell
    """
    # don't consider zeros, since this is for inaccessible regions
    if (source == 0) || (target == 0)
        return
    end

    # loop over all edges
    for edge in graph.edges
        # get source, target, direction of this edge
        this_source, this_target, this_direction = edge.source, edge.target, edge.attributes["direction"]
        # check if adding this edge would be redundant
        if (this_source == source) && (this_target == target) && (this_direction == direction)
            # we already noted this connection; it is present in the graph
            return
        end
    end
    # if we made it this far without returning, then add this edge.
    attr = AttributeDict()  # from Graphs.jl, to store attribute of an edge
    attr["direction"] = direction
    edge = ExEdge(num_edges(graph) + 1, source, target, attr)
    add_edge!(graph, edge)
end
                
function recursively_navigate_graph!(segment_no::Int, 
                                     graph::GenericEdgeList, 
                                     unit_cell::Array{Int},
                                     segment_visit_status::Dict{Int, Bool})
    """
    Recursively navigate edges in the graph to identify pockets and channels
    """
    segment_visit_status[segment_no] = true
    for edge in graph.edges
        if edge.attributes["visited"]
            continue
        end

        # if segment is connected to itself across the periodic boundary, it is a channel.
        if (edge.source == segment_no) && (edge.target == segment_no)
            edge.attributes["visited"] = true
            return "channel"
        end
        
        # check if this edge is a connection from segment_no to edge.target
        if edge.source == segment_no
            # if so, travel along this edge
            edge.attributes["visited"] = true
           
            # in the process of traveling along the edge, we entered a different unit cell
            for i = 1:3
                unit_cell[i] += edge.attributes["direction"][i]
            end
            
            # has the target segment been visited before?
            if ! segment_visit_status[edge.target]
                # if not, use recursion to take another step along the next edge
                return recursively_navigate_graph!(edge.target, graph, unit_cell, segment_visit_status)
            else
                # if this segment has been visited, don't visit it again, but do check if we have ended up
                # in a different unit cell
                if unit_cell != [0, 0, 0]
                    return "channel"
                end
            end
        end  # end loop over if this edge emenates from segment_no
    end  # end loop over edges
    # if made it this far, haven't found it to be a channel...
    return "pocket"
end  # end recursively_navigate_graph()

type Grid
    """
    For interally storing energy grid
    """
    adsorbate::AbstractString
    structurename::AbstractString
    forcefieldname::AbstractString

    # number of grid points
    N_x::Int
    N_y::Int
    N_z::Int

    # fractional grid spacing
    dx_f::Float64
    dy_f::Float64
    dz_f::Float64

    # voxel vectors
    voxel_vectors::Array{Float64}

    # store 3D array of energies here
    energies::Array{Float64}

    # functions
    energy_at::Function  # get energy at a point in fractional space
    min_energy::Function  # get minimum energy among grid points
    index_to_fractional_coord::Function
    flood_fill::Function  # flood fill algo to label segments
    analyze_connections::Function  # analyze connections of segment ids from flood_fill(), returns graph
    classify_segments::Function  # classify segments as pocket or channel
    rewrite_cube::Function  # rewrite cube file
    find_and_block_pockets::Function
    compute_henry_coefficient::Function  # integrate grid to compute Henry coefficient

    function Grid(adsorbate::AbstractString, structurename::AbstractString, forcefieldname::AbstractString)
        """
        Constructor for Grid. Loads previously written cube file
        """
        grid = new()

        grid.adsorbate = adsorbate
        grid.structurename = structurename
        grid.forcefieldname = forcefieldname

        ###
        #   Import information from grid file
        ###
        gridfile = open(homedir() * "/PEGrid_output/" * forcefieldname * "/" * structurename * "_" * adsorbate * ".cube")
        # waste 3 lines
        [readline(gridfile) for i = 1:3]

        voxel_lines = [readline(gridfile) for i = 1:3]
        # get number of grid points
        grid.N_x = parse(Int, split(voxel_lines[1])[1])
        grid.N_y = parse(Int, split(voxel_lines[2])[1])
        grid.N_z = parse(Int, split(voxel_lines[3])[1])
        @printf("N_x = %d, N_y = %d, N_z = %d\n", grid.N_x, grid.N_y, grid.N_z)

        # get voxel information
        grid.voxel_vectors = zeros(Float64, 3, 3)
        for i = 1:3
            grid.voxel_vectors[1, i] = parse(Float64, split(voxel_lines[i])[2])
            grid.voxel_vectors[2, i] = parse(Float64, split(voxel_lines[i])[3])
            grid.voxel_vectors[3, i] = parse(Float64, split(voxel_lines[i])[4])
        end

        grid.energies = zeros((grid.N_x, grid.N_y, grid.N_z))  # 3D array
        
        grid.dx_f = 1.0 / (grid.N_x - 1)
        grid.dy_f = 1.0 / (grid.N_y - 1)
        grid.dz_f = 1.0 / (grid.N_z - 1)
       
        line = readline(gridfile)  
        counter = 1
        for i in 1:grid.N_x  # loop over x_f-grid points
            for j in 1:grid.N_y  # loop over y_f-grid points
                for k in 1:grid.N_z  # loop over z_f-grid points

                    grid.energies[i, j, k] = float(split(line)[counter])
                    counter += 1
                    
                    if (k % 6) == 0
                        counter = 1
                        line = readline(gridfile)
                    end
                end # end loop in z_f-grid points
                line = readline(gridfile)
                counter = 1
            end # end loop in y_f-grid points
        end # end loop in x_f-grid points

        grid.min_energy = function()
            """
            Get minimum energy, index in grid, and frational coords at minimim energy in grid
            """
            idx_max = indmin(grid.energies)  # 1D
            minE = grid.energies[idx_max]
            i_max, j_max, k_max = ind2sub(size(grid.energies), idx_max)

            x_f = ([i_max, j_max, k_max] - 1) .* [grid.dx_f, grid.dy_f, grid.dz_f]  # fractional coordinate here
            return [i_max, j_max, k_max], minE, x_f
        end

        grid.energy_at = function(x_f::Float64, y_f::Float64, z_f::Float64)
            """
            Get energy at fractional coord x_f, y_f, z_f by interpolation
            """
            @assert((x_f >= 0.0) & (y_f >= 0.0) & (z_f >= 0.0))
            @assert((x_f <= 1.0) & (y_f <= 1.0) & (z_f <= 1.0))

            # define indices of 8 grid points on the vertices of the cube surrounding
            # the pt (x_f, y_f, z_f) 
            i_x_low = floor(Integer, x_f / grid.dx_f) + 1;
            i_y_low = floor(Integer, y_f / grid.dy_f) + 1;
            i_z_low = floor(Integer, z_f / grid.dz_f) + 1;
            
            #trilinear interpolation http://en.wikipedia.org/wiki/Trilinear_interpolation
            # difference between our point and the vertex
            x_d = (x_f - (i_x_low-1) * grid.dx_f) / grid.dx_f
            y_d = (y_f - (i_y_low-1) * grid.dy_f) / grid.dy_f
            z_d = (z_f - (i_z_low-1) * grid.dz_f) / grid.dz_f

            # smash cube in x direction
            c00 = (1 - x_d) * grid.energies[i_x_low, i_y_low  , i_z_low  ] + x_d * grid.energies[i_x_low+1, i_y_low  , i_z_low  ]
            c10 = (1 - x_d) * grid.energies[i_x_low, i_y_low+1, i_z_low  ] + x_d * grid.energies[i_x_low+1, i_y_low+1, i_z_low  ]
            c01 = (1 - x_d) * grid.energies[i_x_low, i_y_low  , i_z_low+1] + x_d * grid.energies[i_x_low+1, i_y_low  , i_z_low+1]
            c11 = (1 - x_d) * grid.energies[i_x_low, i_y_low+1, i_z_low+1] + x_d * grid.energies[i_x_low+1, i_y_low+1, i_z_low+1]

            # further smash cube in y direction
            c0 = c00 * (1.0 - y_d) + c10 * y_d
            c1 = c01 * (1.0 - y_d) + c11 * y_d

            # finally, linear interpolation in z direction
            return c0 * (1 - z_d) + c1 * z_d
        end  # end energy_at function

        grid.index_to_fractional_coord = function(i::Int, j::Int, k::Int)
            """
            Convert grid of index to fraction coord that it represents
            """
            return [grid.dx_f * (i-1), grid.dy_f * (j-1), grid.dz_f * (k-1)]
        end

        grid.flood_fill = function(threshold::Float64)
            """
            Flood fill algorithm to identify segments
            label inaccessible points as 0
            labels other connected segments with 1, 2, 3, ...
            
            parameters:
                threshold: energy threshold; pts with energy greater than this are inaccessible
            returns:
                a 3D array of integer classifications of segements of each grid point
            """
            # number of segments found
            n_segments = 0

            # store segment to which each point belongs here (one means not found)
            segment_ids = -ones(Int, (grid.N_x, grid.N_y, grid.N_z))

            # first, classify grid points that are inaccessible with segment ID = 0
            for i = 1:grid.N_x
                for j = 1:grid.N_y
                    for k = 1:grid.N_z
                        if grid.energies[i, j, k] > threshold
                            segment_ids[i, j, k] = 0
                        end
                    end
                end
            end
            # at this point, segment_ids is 0 if inaccessible and -1 if accessible

            # loop over all grid points
            for i = 1:grid.N_x
                for j = 1:grid.N_y
                    for k = 1:grid.N_z
                        # if this grid point has been assigned a segment, continue.
                        if (i, j, k) == (grid.N_x, grid.N_y, 77)
                            println("hello b54")
                        end
                        if segment_ids[i, j, k] != -1
                            continue
                        end
                        n_segments += 1
                        
                        if (i, j, k) == (grid.N_x, grid.N_y, 77)
                            println("hello")
                        end
                        # list of adjacent grid points to consider
                        adjacent_ids = Tuple{Int, Int, Int}[]
                        # add this grid point to adjacent ID list to initialize search
                        push!(adjacent_ids, (i, j, k))

                        while length(adjacent_ids) != 0

                            if (i, j, k) == (grid.N_x, grid.N_y, grid.N_z)
                                println(adjacent_ids)
                            end
                            # get a point from the list of adjacent IDs
                            grid_pt = pop!(adjacent_ids)

                            # for clarity, get indices of this grid point
                            i_, j_, k_ = grid_pt

                            # this grid point is in the same segment as (i, j, k)
                            segment_ids[i_, j_, k_] = n_segments

                            # look at surrounding points, if not found: add to stack
                            if (i_ != 1) && (segment_ids[i_-1, j_, k_] == -1)
                                push!(adjacent_ids, (i_-1, j_, k_))
                            end
                            if (i_ != grid.N_x) && (segment_ids[i_+1, j_, k_] == -1)
                                push!(adjacent_ids, (i_+1, j_, k_))
                            end
                            
                            if (j_ != 1) && (segment_ids[i_, j_-1, k_] == -1)
                                push!(adjacent_ids, (i_, j_-1, k_))
                            end
                            if (j_ != grid.N_y) && (segment_ids[i_, j_+1, k_] == -1)
                                push!(adjacent_ids, (i_, j_+1, k_))
                            end
                            
                            if (k_ != 1) && (segment_ids[i_, j_, k_-1] == -1)
                                push!(adjacent_ids, (i_, j_, k_-1))
                            end
                            if (k_ != grid.N_z) && (segment_ids[i_, j_, k_+1] == -1)
                                push!(adjacent_ids, (i_, j_, k_+1))
                            end
                        end  # end loop over adjacent_ids list
                    end  # end k loop
                end  # end j loop
            end  # end i loop
            
            assert(sum(segment_ids .== -1) == 0)  # assert all found status
            return segment_ids
        end  # end flood_fill()
        
        grid.analyze_connections = function(segment_ids)
            """
            Create graph of connections between segments by looking at faces of unit cell
            
            parameters:
                segment_ids: 3D array of integer classifications of segments from grid.flood_fill()
            returns:
                graph of connections between segments
            """
            # number of segments
            n_segments = length(unique(segment_ids)) - 1

            # create edge list. vertices are accessible segments. add edges later.
            # we need to keep track of not only source --> target vertex in the graph, but
            # also the direction across the unit cell that we are traveling (a tuple)
            segment_connections = edgelist([i for i = 1:n_segments], [])  # Graphs.jl

            # x-y plane, connections in the positive z-direction
            for i = 1:grid.N_x
                for j = 1:grid.N_y
                    note_new_connection(segment_connections,
                                        segment_ids[i, j, grid.N_z], 
                                        segment_ids[i, j, 1], 
                                        (0, 0, 1))
                    note_new_connection(segment_connections,
                                        segment_ids[i, j, 1], 
                                        segment_ids[i, j, grid.N_z], 
                                        (0, 0, -1))
                end
            end
            
            # x-z plane, connections in the positive z-direction
            for i = 1:grid.N_x
                for k = 1:grid.N_z
                    note_new_connection(segment_connections,
                                        segment_ids[i, grid.N_y, k],
                                        segment_ids[i, 1, k], 
                                        (0, 1, 0))
                    note_new_connection(segment_connections,
                                        segment_ids[i, 1, k],
                                        segment_ids[i, grid.N_y, k], 
                                        (0, -1, 0))
                end
            end
            
            # x-z plane, connections in the positive z-direction
            for j = 1:grid.N_y
                for k = 1:grid.N_z
                    note_new_connection(segment_connections,
                                        segment_ids[grid.N_x, j, k],
                                        segment_ids[1, j, k],
                                        (1, 0, 0))
                    note_new_connection(segment_connections,
                                        segment_ids[1, j, k],
                                        segment_ids[grid.N_x, j, k],
                                        (-1, 0, 0))
                end
            end

            return segment_connections
        end  # end analyze_connections()

        grid.classify_segments = function(graph::GenericEdgeList)
            """
            Walk through the graph and classify each segment as a pocket or channel
            returns:
                Dict() of classifiations (channel or pocket)
            """
            n_segments = maximum(graph.vertices)
            # store classification here (unknown, channel, or pocket)
            segment_classification = Dict([i => "unknown" for i=1:n_segments])
            
            for s = 1:n_segments
                # label each edge as not vistied
                for edge in graph.edges
                    edge.attributes["visited"] = false
                end
                # label each segment as not visited
                segment_visit_status = Dict{Int, Bool}([i => false for i=1:n_segments])
                
                # start off in home unit cell
                unit_cell = [0, 0, 0]
                segment_classification[s] = recursively_navigate_graph!(s, graph, unit_cell, segment_visit_status)
            end

            return segment_classification
        end

        grid.find_and_block_pockets = function(energy_threshold::Float64)
            """
            Find and block inaccessible pockets
            Inaccessible is defined as having energy > energy_threshold

            Overwrite inaccessible grid points with large energy
            """
            verbose_flag = true
            if verbose_flag
                @printf("Flood fill algorithm initiated for segmentations...\n")
            end
            segment_ids = grid.flood_fill(energy_threshold)
            @printf("\tFinished. %d segments found.\n", length(unique(segment_ids)) - 1)

            if verbose_flag
                @printf("Analyzing connections between segments...\n")
            end
            graph = grid.analyze_connections(segment_ids)
            if verbose_flag
                @printf("Classifying segments as channels or pockets...\n")
            end
            segment_classification = grid.classify_segments(graph)
            if verbose_flag
                for (segment, classification) in segment_classification
                    @printf("\tSegment %d => %s\n", segment, classification)
                end
            end

            OVERWRITE_VALUE = 1e6

            for i = 1:grid.N_x
                for j = 1:grid.N_y
                    for k = 1:grid.N_z
                        if segment_ids[i, j, k] == 0
                            continue
                        end
                        if segment_classification[segment_ids[i, j, k]] == "pocket"
                            grid.energies[i, j, k] = OVERWRITE_VALUE
                        end
                    end
                end
            end  # end loop over grid points
            return segment_classification, graph
        end  # end find_and_block_pockets()

        grid.rewrite_cube = function()
            """
            Rewrite .cube file in PEGrid_output
            """
            gridfilename = homedir() * "/PEGrid_output/" * grid.forcefieldname *
                            "/" * grid.structurename * "_" * grid.adsorbate *
                            "_v2.cube"
            gridfile = open(gridfilename, "w")

            # Format of .cube described here http://paulbourke.net/dataformats/cube/
            write(gridfile, "This is a grid file generated by PEgrid\nLoop order: x, y, z\n")
            @printf(gridfile, "%d %f %f %f\n" , 0, 0.0, 0.0, 0.0)  # 0 atoms, then origin
            @printf(gridfile, "%d %f %f %f\n" , grid.N_x, 
                    grid.voxel_vectors[1, 1], grid.voxel_vectors[2, 1], grid.voxel_vectors[3, 1])
            @printf(gridfile, "%d %f %f %f\n" , grid.N_y, 
                    grid.voxel_vectors[1, 2], grid.voxel_vectors[2, 2], grid.voxel_vectors[3, 2])
            @printf(gridfile, "%d %f %f %f\n" , grid.N_z, 
                    grid.voxel_vectors[1, 3], grid.voxel_vectors[2, 3], grid.voxel_vectors[3, 3])

            for i in 1:grid.N_x
                for j in 1:grid.N_y
                    for k in 1:grid.N_z
                        @printf(gridfile, "%e ", grid.energies[i, j, k])
                        if (k % 6) == 0
                            @printf(gridfile, "\n")
                        end
                    end # end loop in z_f-grid points
                    @printf(gridfile, "\n")
                end # end loop in y_f-grid points
            end # end loop in x_f-grid points
            close(gridfile)
            @printf("\tDone.\nGrid available in %s\n", gridfilename)
        end

        grid.compute_henry_coefficient = function(temperature::Float64)
            """
            Compute Henry coefficient by integrating the grid.
            KH = < e ^ {- E / (RT) } > / (RT)

            returns:
                henry coefficient
            """
            # do not consider grid points at the end of the cell, as these are redundant to the first face
            # i.e. via periodic boundary conditions, grid.energies[1,1,1] = grid.energies[N_x, N_y, N_z]...
            henry_coefficient = 0.0
            for i = 2:grid.N_x
                for j = 2:grid.N_y
                    for k = 2:grid.N_z
                        henry_coefficient += exp(-grid.energies[i, j, k] * 1000.0 / 8.314 / temperature) 
                    end
                end
            end
            # divide by number of samples
            henry_coefficient /= (grid.N_x - 1) * (grid.N_y - 1) * (grid.N_z - 1)
            # divide by RT
            henry_coefficient /= 8.314 * temperature
            return henry_coefficient  # units: (mol/m3-Pa)
        end
        
        return grid
    end  # end constructor
end  # end Grid type
